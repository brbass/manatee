#include <iostream>
#include <string>

#include <Teuchos_Time.hpp>

#include <Monte_Carlo.hh>
#include <SP1_Transport.hh>

int test_weighted_mc()
{
    using namespace std;
    using namespace mesh_ns;
    using namespace data_ns;
    using namespace monte_carlo_ns;
    using namespace transport_ns;
    
    // initialize mutual variables
    unsigned number_of_cells = 10;
    unsigned number_of_groups = 2;
    unsigned number_of_scattering_moments = 2;
    
    double side_length = 10;//22.017156;
    vector<double> internal_source(number_of_cells * number_of_groups, 0.0);
    vector<double> boundary_sources(number_of_groups * 2, 0.0);
    vector<double> sigma_t(number_of_cells * number_of_groups, 3.0);
    vector<double> sigma_s(number_of_cells * number_of_groups * number_of_groups * number_of_scattering_moments, 0.0);
    for (unsigned i = 0; i < number_of_cells; ++i)
    {
        internal_source[0 + number_of_groups * i] = 1;
        
        for (unsigned gf = 0; gf < number_of_groups; ++gf)
        {
            for (unsigned gt = 0; gt < number_of_groups; ++gt)
            {
                unsigned m = 0;
                unsigned k1 = gf + number_of_groups * (gt + number_of_groups * (i + number_of_cells * m));
                
                m = 1;
                unsigned k2 = gf + number_of_groups * (gt + number_of_groups * (i + number_of_cells * m));

                if (gf == gt - 1)
                {
                    sigma_s[k1] = 0.5;
                    sigma_s[k2] = 0.1;
                }
                else if (gf == gt)
                {
                    sigma_s[k1] = 2.0;
                    sigma_s[k2] = 0.4;
                }
            }
        }
    }
    vector<double> chi(number_of_cells * number_of_groups, 1.0);
    
    // solve sp1 equation for adjoint
    vector<double> nu_sigma_f(number_of_cells * number_of_groups, 0.0);
    vector<string> boundary_conditions(2, "marshak"); // dirichlet, marshak, robin
    string problem_type = "forward";
    
    SP1_Transport sp1_transport(number_of_cells,
                                number_of_groups,
                                number_of_scattering_moments,
                                side_length,
                                internal_source, // use total cross section as response
                                boundary_sources,
                                sigma_t,
                                sigma_s,
                                nu_sigma_f,
                                chi,
                                boundary_conditions,
                                problem_type);
    
    sp1_transport.solve();
    
    sp1_transport.print_scalar_flux();
    
    vector<double> phi_adjoint = sp1_transport.get_scalar_flux();
    
    // solve using monte carlo and weight windows
    boundary_conditions.assign(2, "reflected");
    unsigned number_of_histories = 1e6;
    bool implicit_capture = true;
    number_of_scattering_moments = 1;
    
    vector<double> nu(number_of_cells * number_of_groups, 0.0*1.70);
    vector<double> sigma_f(number_of_cells * number_of_groups, 0.0*0.054628);
    
    Monte_Carlo monte_carlo(number_of_cells,
                            number_of_groups,
                            number_of_scattering_moments,
                            number_of_histories,
                            side_length,
                            internal_source,
                            boundary_sources,
                            sigma_t,
                            sigma_s,
                            nu,
                            sigma_f,
                            chi,
                            boundary_conditions,
                            implicit_capture);
    
    //monte_carlo.initialize_weight_windows(phi_adjoint);
    
    monte_carlo.solve();
    
    monte_carlo.print_scalar_flux();
    
    return 0;
}


int main():
{
    test_weighted_mc();
}
