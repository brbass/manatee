#include "SPn_Transport.hh"

#include <string>
#include <vector>
#include <Epetra_MpiComm.h>
#include <Epetra_Map.h>
#include <Epetra_CrsMatrix.h>
#include <Epetra_MultiVector.h>
#include <Epetra_LinearProblem.h>
#include <Amesos.h>

#include "Data.hh"
#include "Mesh.hh"

namespace transport_ns
{
    using std::vector;
    using namespace data_ns;
    using namespace mesh_ns;
    
    SPn_Transport::
    SPn_Transport(Data &data,
                  Mesh &mesh):
        data_(data),
        mesh_(mesh)
    {
        data_.check();
        mesh_.check();
    }

    SPn_Transport::
    ~SPn_Transport()
    {
        delete map_;
        delete comm_;
        delete matrix_;
        delete lhs_;
        delete rhs_;
        delete problem_;
        delete solver_;
    }
    
    int SPn_Transport::
    solve()
    {
        solver_->Solve();
        
        return 0;
    }

    int SPn_Transport::
    initialize_solver()
    {
        num_global_elements_ = data_.number_of_cells() * data_.number_of_groups() * data_.number_of_scattering_moments();
        
        comm_ = new Epetra_MpiComm(MPI_COMM_WORLD);
        map_ = new Epetra_Map(num_global_elements_, index_base_, *comm_);
        
        num_my_elements_ = map_->NumMyElements();
        my_global_elements_.assign(map_->MyGlobalElements(), map_->MyGlobalElements() + n);
        
        num_entries_per_row_.resize(num_my_elements_, 0);
        
        for (int i = 0; i < num_my_elements_; ++i)
        {
            int j = my_global_elements_[i];
            
            if (j < num_off_diagonals_)
            {
                num_entries_per_row_[i] = num_off_diagonals_ + j + 1;
            }
            else if (j >= num_global_elements_ - num_off_diagonals_)
            {
                num_entries_per_row_[i] = num_global_elements_ + num_off_diagonals_ - j;
            }
            else
            {
                num_entries_per_row_[i] = num_diagonals_;
            }
        }
        
        matrix_ = new Epetra_CrsMatrix(Copy, *map_, &num_entries_per_row_[0], true);
        
        for (int i = 0; i < num_my_elements_; ++i)
        {
            std::vector<double> values(num_entries_per_row_[i], 0);
            std::vector<int> indices(num_entries_per_row_[i], 0);
            
            int j = my_global_elements_[i];
            
            if (j < num_off_diagonals_)
            {
                for (int k = 0; k < num_entries_per_row_[i]; ++k)
                {
                    indices[k] = k;
                    values[k] = distribution_(generator_);
                }
            }
            else
            {
                for (int k = 0; k < num_entries_per_row_[i]; ++k)
                {
                    indices[k] = j - num_off_diagonals_ + k;
                    values[k] = distribution_(generator_);
                }
            }
            
            matrix_->InsertGlobalValues(j, num_entries_per_row_[i], &values[0], &indices[0]);
        }
        
        lhs_ = new Epetra_MultiVector(*map_, num_vectors_);
        rhs_ = new Epetra_MultiVector(*map_, num_vectors_);
        
        lhs_->PutScalar(0.0);
        rhs_->Random();
        
        matrix_->FillComplete();
        
        problem_ = new Epetra_LinearProblem(matrix_, lhs_, rhs_);
        
        solver_ = factory_.Create(solver_type_, *problem_);
        
        if (solver_ == NULL)
        {
            std::cerr << "Specified solver \"" << solver_type_ << "\" is not available." << std::endl;
        }
        
        list_.set("PrintTiming", true);
        list_.set("PrintStatus", true);
        
        solver_->SetParameters(list_);

        solver_->SymbolicFactorization();
        
        solver_->NumericFactorization();
        
    }
}
