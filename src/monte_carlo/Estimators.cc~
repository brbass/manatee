#include "Estimators.hh"

#include <cmath>
#include <iostream>

namespace monte_carlo_ns
{
    using namespace std;
    
    Estimators::
    Estimators(unsigned number_of_cells,
               unsigned number_of_surfaces,
               unsigned number_of_groups,
               bool track_variance):
        number_of_cells_(number_of_cells),
        number_of_surfaces_(number_of_surfaces),
        number_of_groups_(number_of_groups),
        ongoing_history_(false),
        number_of_histories_(0)
    {
        current_.size_ = number_of_surfaces_ * number_of_groups_;
        surface_flux_.size_ = number_of_surfaces_ * number_of_groups_;
        volume_flux_.size_ = number_of_cells_ * number_of_groups_;
        collision_flux_.size_ = number_of_cells_ * number_of_groups_;
        
        zero_total_vectors();
    }
    
    void Estimators::
    begin_history()
    {
        if (ongoing_history_)
        {
            cerr << "history already started" << endl;
        }
        else
        {
            ongoing_history_ = true;
            
            zero_history_vectors();
        }
    }
    
    void Estimators::
    end_history()
    {
        if (!ongoing_history_)
        {
            cerr << "history not yet begun" << endl;
        }
        else
        {
            ongoing_history_ = false;
            number_of_histories_ += 1;
            
            sum_history_vectors();
        }
    }
    
    void Estimators::
    zero_history_vectors()
    {
        for (unsigned j = 0; j < estimators_.size(); ++j)
        {
            estimators_[j]->history_.assign(estimators_[j]->size_, 0.0);
        }
    }
    
    void Estimators::
    zero_total_vectors()
    {
        for (unsigned j = 0; j < estimators_.size(); ++j)
        {
            estimators_[j]->total_.assign(estimators_[j]->size_, 0.0);
            estimators_[j]->total_squared_.assign(estimators_[j]->size_, 0.0);
        }
    }
    
    void Estimators::
    sum_history_vectors()
    {
        for (unsigned j = 0; j < estimators_.size(); ++j)
        {
            for (unsigned i = 0; i < estimators_[j]->size_; ++i)
            {
                estimators_[j]->total_[i] += estimators_[j]->history_[i];
                estimators_[j]->total_squared_[i] += pow(estimators_[j]->history_[i], 2);
            }
        }
    }

    void Estimators::
    normalize()
    {
        for (unsigned j = 0; j < estimators_.size(); ++j)
        {
            for (unsigned i = 0; i < estimators_[j]->size_; ++i)
            {
                estimators_[j]->total_[i] /= total_histories_;
                estimators_[j]->total_squared_[i] /= total_histories_;
            }
        }
    }
    
    void Estimators::
    add_track(unsigned cell,
              unsigned group,
              double weight,
              double length)
    {
        volume_flux_.history_[group + number_of_groups_ * cell] += weight * length;
    }

    void Estimators::
    add_collision(unsigned cell,
                  unsigned group,
                  double weight,
                  double sigma_t)
    {
        collision_flux_.history_[group + number_of_groups_ * cell] += weight / sigma_t;
    }
    
    void Estimators::
    add_crossing(unsigned surface,
                 unsigned group,
                 double weight,
                 double ordinate)
    {
        current_.history_[group + number_of_groups_ * surface] += weight;
        surface_flux_.total_[group + number_of_groups_ * surface] += weight / abs(ordinate);
    }
}
